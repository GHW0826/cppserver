cmake_minimum_required(VERSION 3.19)
project(Server LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

if (CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(ARCH_DIR "x64")
elseif (CMAKE_SIZEOF_VOID_P EQUAL 4)
    set(ARCH_DIR "x86")
else()
    set(ARCH_DIR "unknown")
endif()

if (NOT CMAKE_CONFIGURATION_TYPES)
    if (NOT CMAKE_BUILD_TYPE)
        set(CMAKE_BUILD_TYPE Debug CACHE STRING "Build type" FORCE)
    endif()
    set(PROTO_CONFIG_DIR "${CMAKE_BUILD_TYPE}")
else()
    set(PROTO_CONFIG_DIR "$<CONFIG>")
endif()

# =========================
# Paths (ROOT는 CMakeLists 위치 기준으로 안정화)
# =========================
set(ROOT_DIR "${CMAKE_CURRENT_LIST_DIR}/..")

# -------------------------
# Protobuf include dir (google/ 폴더 바로 위)
# -------------------------
set(PROTOBUF_INCLUDE_DIR "${ROOT_DIR}/Include/Protobuf")
if (NOT EXISTS "${PROTOBUF_INCLUDE_DIR}")
    message(FATAL_ERROR "Protobuf include dir not found: '${PROTOBUF_INCLUDE_DIR}'")
endif()

add_library(Protobuf::libprotobuf STATIC IMPORTED GLOBAL)

if (CMAKE_CONFIGURATION_TYPES)
    # ===== Multi-config (Debug/Release etc.) =====

    set(PROTOBUF_DIR_DEBUG   "${ROOT_DIR}/Lib/Protobuf/Debug/${ARCH_DIR}")
    set(PROTOBUF_DIR_RELEASE "${ROOT_DIR}/Lib/Protobuf/Release/${ARCH_DIR}")

    # Debug: d가 있으면 그걸 쓰고, 없으면 일반 libprotobuf.a로 fallback
    set(PROTOBUF_LIB_DEBUG "${PROTOBUF_DIR_DEBUG}/libprotobufd.a")
    if (NOT EXISTS "${PROTOBUF_LIB_DEBUG}")
        set(PROTOBUF_LIB_DEBUG "${PROTOBUF_DIR_DEBUG}/libprotobuf.a")
    endif()

    set(PROTOBUF_LIB_RELEASE "${PROTOBUF_DIR_RELEASE}/libprotobuf.a")

    # 존재 검증(원인 빨리 잡히게)
    if (NOT EXISTS "${PROTOBUF_LIB_DEBUG}")
        message(FATAL_ERROR "Protobuf Debug lib not found: '${PROTOBUF_LIB_DEBUG}'")
    endif()
    if (NOT EXISTS "${PROTOBUF_LIB_RELEASE}")
        message(FATAL_ERROR "Protobuf Release lib not found: '${PROTOBUF_LIB_RELEASE}'")
    endif()

    set_target_properties(Protobuf::libprotobuf PROPERTIES
        IMPORTED_LOCATION_DEBUG          "${PROTOBUF_LIB_DEBUG}"
        IMPORTED_LOCATION_RELEASE        "${PROTOBUF_LIB_RELEASE}"
        IMPORTED_LOCATION_RELWITHDEBINFO "${PROTOBUF_LIB_RELEASE}"
        IMPORTED_LOCATION_MINSIZEREL     "${PROTOBUF_LIB_RELEASE}"

        MAP_IMPORTED_CONFIG_RELWITHDEBINFO Release
        MAP_IMPORTED_CONFIG_MINSIZEREL     Release

        INTERFACE_INCLUDE_DIRECTORIES "${PROTOBUF_INCLUDE_DIR}"
    )

else()
    # ===== Single-config (CMAKE_BUILD_TYPE 사용) =====
    if (NOT CMAKE_BUILD_TYPE)
        set(CMAKE_BUILD_TYPE Debug CACHE STRING "Build type" FORCE)
    endif()

    set(PROTOBUF_LIB_DIR "${ROOT_DIR}/Lib/Protobuf/${CMAKE_BUILD_TYPE}/${ARCH_DIR}")
    set(PROTOBUF_LIB_PATH "${PROTOBUF_LIB_DIR}/libprotobuf.a")
    if (CMAKE_BUILD_TYPE STREQUAL "Debug" AND EXISTS "${PROTOBUF_LIB_DIR}/libprotobufd.a")
        set(PROTOBUF_LIB_PATH "${PROTOBUF_LIB_DIR}/libprotobufd.a")
    endif()

    if (NOT EXISTS "${PROTOBUF_LIB_PATH}")
        message(FATAL_ERROR "Protobuf lib not found: '${PROTOBUF_LIB_PATH}'")
    endif()

    set_target_properties(Protobuf::libprotobuf PROPERTIES
        IMPORTED_LOCATION "${PROTOBUF_LIB_PATH}"
        INTERFACE_INCLUDE_DIRECTORIES "${PROTOBUF_INCLUDE_DIR}"
    )
endif()

# Core Lib Source (Generated by Python)
set(CORE_SOURCES
{% for src_file in source_files -%}
    "{{ src_file }}"
{% endfor %}
)

# Create static Lib
add_library(Core STATIC ${CORE_SOURCES})


target_link_libraries(Core PUBLIC Protobuf::libprotobuf)
if (UNIX AND NOT APPLE)
    find_package(Threads REQUIRED)
    target_link_libraries(Core PUBLIC Threads::Threads dl)
endif()


# header include path
target_include_directories(Core PUBLIC
"${CMAKE_CURRENT_SOURCE_DIR}/Include/Protobuf"
{% for inc_dir in include_dirs -%}
    "{{ inc_dir }}"
{% endfor %}
)

# ===== Already Compiled Header Set (CMake 3.16+ Recommand) =====
target_precompile_headers(Core PRIVATE
    "$<$<COMPILE_LANGUAGE:CXX>:pch.h>"
)

# Core Lib Output Path
set_target_properties(Core PROPERTIES
    ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/../../Lib/Core/${CMAKE_BUILD_TYPE}/${ARCH_DIR}"
)




set(CORE_HEADERS_DST_ROOT "${ROOT_DIR}/Include/Core")

# Copy Header
set(CORE_HEADERS_TO_COPY
{% for src_file, _ in hpp_source_files -%}
    "${CMAKE_CURRENT_SOURCE_DIR}{{ src_file }}"
{% endfor %}
)

add_custom_command(TARGET Core POST_BUILD
    COMMAND "${CMAKE_COMMAND}" -E make_directory "${CORE_HEADERS_DST_ROOT}"
    COMMAND "${CMAKE_COMMAND}" -E echo "Copy selected core headers -> ${CORE_HEADERS_DST_ROOT}"
    {% for src_file, file_name in hpp_source_files -%}
    COMMAND "${CMAKE_COMMAND}" -E copy_if_different
                    "${CMAKE_CURRENT_SOURCE_DIR}{{ src_file }}"
                    "${CORE_HEADERS_DST_ROOT}/{{ file_name }}"
    {% endfor %}
    COMMENT "Copy headers -> ${CORE_HEADERS_DST_ROOT}"
    VERBATIM
)
